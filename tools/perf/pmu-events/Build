pmu-events-y	+= pmu-events.o
JDIR		=  pmu-events/arch/$(SRCARCH)
JSON		=  $(shell find pmu-events/arch -name *.json -o -name *.csv)
JDIR_TEST	=  pmu-events/arch/test
JSON_TEST	=  $(shell [ -d $(JDIR_TEST) ] &&			\
			find $(JDIR_TEST) -name '*.json')
JEVENTS_PY	=  pmu-events/jevents.py
METRIC_PY	=  pmu-events/metric.py
METRIC_TEST_PY	=  pmu-events/metric_test.py
EMPTY_PMU_EVENTS_C = pmu-events/empty-pmu-events.c
PMU_EVENTS_C	=  $(OUTPUT)pmu-events/pmu-events.c
METRIC_TEST_LOG	=  $(OUTPUT)pmu-events/metric_test.log
TEST_EMPTY_PMU_EVENTS_C = $(OUTPUT)pmu-events/test-empty-pmu-events.c
EMPTY_PMU_EVENTS_TEST_LOG = $(OUTPUT)pmu-events/empty-pmu-events.log

ifeq ($(JEVENTS_ARCH),)
JEVENTS_ARCH=$(SRCARCH)
endif
JEVENTS_MODEL ?= all

#
# Locate/process JSON files in pmu-events/arch/
# directory and create tables in pmu-events.c.
#

ifeq ($(NO_JEVENTS),1)
$(PMU_EVENTS_C): $(EMPTY_PMU_EVENTS_C)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)cp $< $@
else
# Extract the model from a extra-metrics.json or extra-metricgroups.json path
model_name = $(shell echo $(1)|sed -e 's@.\+/\(.*\)/extra-metric.*\.json@\1@')
vendor_name = $(shell echo $(1)|sed -e 's@.\+/\(.*\)/[^/]*/extra-metric.*\.json@\1@')

# Copy checked-in json for generation.
$(OUTPUT)pmu-events/arch/%: pmu-events/arch/%
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)cp $< $@

GEN_METRIC_DEPS := pmu-events/metric.py pmu-events/common_metrics.py

# Generate AMD Json
ZENS = $(shell ls -d pmu-events/arch/x86/amdzen*)
ZEN_METRICS = $(foreach x,$(ZENS),$(OUTPUT)$(x)/extra-metrics.json)
ZEN_METRICGROUPS = $(foreach x,$(ZENS),$(OUTPUT)$(x)/extra-metricgroups.json)

$(ZEN_METRICS): pmu-events/amd_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< $(call model_name,$@) pmu-events/arch > $@

$(ZEN_METRICGROUPS): pmu-events/amd_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< -metricgroups $(call model_name,$@) pmu-events/arch > $@

# Generate ARM Json
ARMS = $(shell ls -d pmu-events/arch/arm64/arm/*)
ARM_METRICS = $(foreach x,$(ARMS),$(OUTPUT)$(x)/extra-metrics.json)
ARM_METRICGROUPS = $(foreach x,$(ARMS),$(OUTPUT)$(x)/extra-metricgroups.json)

$(ARM_METRICS): pmu-events/arm64_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< $(call vendor_name,$@) $(call model_name,$@) pmu-events/arch > $@

$(ARM_METRICGROUPS): pmu-events/arm64_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< -metricgroups $(call vendor_name,$@) $(call model_name,$@) pmu-events/arch > $@

# Generate Intel Json
INTELS = $(shell ls -d pmu-events/arch/x86/*|grep -v amdzen|grep -v mapfile.csv)
INTEL_METRICS = $(foreach x,$(INTELS),$(OUTPUT)$(x)/extra-metrics.json)
INTEL_METRICGROUPS = $(foreach x,$(INTELS),$(OUTPUT)$(x)/extra-metricgroups.json)

$(INTEL_METRICS): pmu-events/intel_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< $(call model_name,$@) pmu-events/arch > $@

$(INTEL_METRICGROUPS): pmu-events/intel_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< -metricgroups $(call model_name,$@) pmu-events/arch > $@

GEN_JSON = $(patsubst %,$(OUTPUT)%,$(JSON)) \
            $(ZEN_METRICS) $(ZEN_METRICGROUPS) \
            $(ARM_METRICS) $(ARM_METRICGROUPS) \
            $(INTEL_METRICS) $(INTEL_METRICGROUPS)

$(METRIC_TEST_LOG): $(METRIC_TEST_PY) $(METRIC_PY)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,test)$(PYTHON) $< 2> $@ || (cat $@ && false)

$(TEST_EMPTY_PMU_EVENTS_C): $(JSON) $(JSON_TEST) $(JEVENTS_PY) $(METRIC_PY) $(METRIC_TEST_LOG)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $(JEVENTS_PY) none none pmu-events/arch $@

$(EMPTY_PMU_EVENTS_TEST_LOG): $(EMPTY_PMU_EVENTS_C) $(TEST_EMPTY_PMU_EVENTS_C)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,test)diff -u $^ 2> $@ || (cat $@ && false)

$(PMU_EVENTS_C): $(GEN_JSON) $(JSON_TEST) $(JEVENTS_PY) $(METRIC_PY) $(METRIC_TEST_LOG) $(EMPTY_PMU_EVENTS_TEST_LOG)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $(JEVENTS_PY) $(JEVENTS_ARCH) $(JEVENTS_MODEL) $(OUTPUT)pmu-events/arch $@
endif

# pmu-events.c file is generated in the OUTPUT directory so it needs a
# separate rule to depend on it properly
$(OUTPUT)pmu-events/pmu-events.o: $(PMU_EVENTS_C)
	$(call rule_mkdir)
	$(call if_changed_dep,cc_o_c)
